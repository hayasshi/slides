# Chapter 4 クラスとオブジェクト

## クラス、フィールド、メソッド

* 基本的にJavaと同じ
```scala
class ScalaClass {
  val myField = "hoge"
  private var myStatus = "01"

  def run(): String = {
    setStatus("02")
    myStatus
  }

  def end(): String = {
    setStatus("03")
    myStatus
  }

  private def setStatus(status: String) {
    myStatus = status
  }
}
```

* メソッド引数は"val"


* returnは省略できる
    * 早期returnは使わない
    * メソッドは1つの値を生成する式→設計レベルで意識する必要あり


* メソッドのシグネチャと実装の間の"="に注意
    * "="が無いと(手続き型記述)返り値がすべてUnitになる
```scala
def a() {
  "hoge"
}
def b(): Unit = "hoge"
```

## セミコロンの扱い

* セミコロンは基本的に不要
    * 1行に複数文記載する場合に使用する
    * 復数文またがる場合もScalaが分割

```scala
// OK
if (flag)
  println("true")
else
  println("false")

// NG
val sum = x
+ y
```


* セミコロン推論の規則
次の条件に当てはまる場合は、行末セミコロンとして扱われない
    1. 該当行の末尾が、ピリオドや中置演算子などの文の末尾として文法的に認められていない単語になっている
    1. 次の行の先頭が、文の先頭として認められない単語になっている
    1. 括弧()や角括弧[]の中にいる状態で文末になっている

## シングルトンオブジェクト

* Scalaはstaticメンバを持てない
    * 代わりにシングルトンオブジェクト(Singleton Object)を利用できる


* obectキーワードで指定する
```scala
object ScalaStatic {
  val value = "hoge"
}
println(ScalaStatic.value)
```


* staticと同じようなものだが、フィールドやメソッドは同名のクラスに属していない
    * Javaはクラスの共通領域で管理される
    * シングルトンオブジェクトはそれが唯一のインスタンスとして扱われる


* シングルトンオブジェクトと同じ名前のクラスがある場合、下記のような呼び方をされる
    * シングルトンオブジェクト→コンパニオンオブジェクト
    * 同名のクラス→コンパニオンクラス
    * 同一のソースファイルに記載される必要がある
    * コンパニオン同士はお互いの非公開メンバにアクセスできる
    * 逆にコンパニオンクラスのないシングルトンオブジェクトは「スタンドアロンオブジェクト」と呼ばれる

```scala
class Sample {
  private val value = "foo"
}
object Sample {
  private val value = "bar"
}
// それぞれのvalueは別物
```

* コンパニオンオブジェクトはクラスとは別のクラスやトレイトを継承・ミックスインできる


* Javaのバイトコード的にはstatic領域に無名内部クラスのインスタンスがセットされる
    * 初期化セマンティクスがJavaのstaticメンバと同じ
    * 最初にアクセスされた時に初期化される

## Scalaアプリケーションのエントリーポイント

* Scalaのエントリーポイント(プログラム実行開始)は、スタンドアロンオブジェクトのmainメソッド
```scala
object HogeFuga {
  def main(args: String): Unit = {
    // run program
  }
}
```


* Scalaはソースファイルに好きな名前をつけることができるが慣習的にJavaと同じ命名規則が用いられる


* Scalaのソースは暗黙的に下記のパッケージやオブジェクトがインポートされる
    * java.lang._
    * scala._
    * scala.Predef._


# Chapter 5 基本型と演算子

## 基本型

|値型            |範囲                               |
|:---------------|:----------------------------------|
|Byte            |2の補数表現の8ビット符号付き整数   |
|Short           |2の補数表現の16ビット符号付き整数  |
|Int             |2の補数表現の32ビット符号付き整数  |
|Long            |2の補数表現の64ビット符号付き整数  |
|Char            |16ビット符号なしUnicode文字        |
|String          |Charのシーケンス                   |
|Float           |32ビットのIEEE754単精度浮動小数点  |
|Double          |64ビットのIEEE754倍精度浮動小数点  |
|Boolean         |true または false                  |

* int, doubleなども使えるが、いつ削除されるかわからない

## リテラル

* 整数リテラル、浮動小数点リテラル、文字リテラル、BooleanリテラルはJavaと同じ
* 文字列リテラルも基本は同じだがヒアドキュメントがある
    * """〜〜〜""" のようにダブルクォート3つで開始終了
    ```scala
    val s1 = """foo
                bar"""
    val s2 = """|foo
                |bar""".stripMargin
    println(s1)
    println(s2)
    ```

## シンボル(Symbol)

* 文字列みたいなもの
* そのJVMプロセスで同じシンボルは同じインスタンスを表す
* 'foobar == Symbol("foobar")

## 演算子

* Scalaの演算子はすべてメソッド
* 1 + 2 == 1.+(2) の糖衣構文
* 自分で作るメソッドにも記号が使えるので演算子を作れる
* 中置(infix)演算子
* 前置(prefix)演算子
* 後置(postfix)演算子
    * 前置、後置演算子は単項(unary)演算子
    * 単行演算子で使用でき記号は「+,-,!,~」
    * 例えば-2.0は「(2.0).unary_-」
    * 例えば!trueは「(true).unary_!」
* メソッドで引数を取らないメソッドは()を省略できる
    * 10.toString
    * 慣習的に副作用のないものは省略する
    * 慣習的に副作用のあるものは省略しない
* 算術演算(+,-,*,/,%)、関係演算(<,>,<=,>=,!)、論理演算(&&,||)
* ビット演算(&,|,^,~)
* 等価演算(==,!=)
    * Javaとはことなりオブジェクト参照の等価ではない
    * null安全
    * 内部的には左辺がnullでなければequalsメソッドをつかう
        * case classは自動でequalsメソッドをオーバーライド
    * 参照の等価をチェックするには「eq,ne」メソッドを利用する

## 演算子の優先順位

* 演算子(メソッド)の評価順序は、メソッドの先頭文字によって優先順位が決められている

    |優先順位|記号                  |
    |:------:|:---------------------|
    |高      |(他のすべての特殊文字)|
    |↑       |* / %                 |
    |        |+ -                   |
    |        |:                     |
    |        |= !                   |
    |        |< >                   |
    |        |&                     |
    |        |^                     |
    |        |&#124;                |
    |↓       |(すべての英字)        |
    |低      |(すべての代入演算子)  |

* Javaと同じくわからなくなりそうであれば()でくくったり別式(別行)で記述する

## リッチラッパー

* [1 max 2]や["32".toInt]のような基本型には含まれないメソッドが使える
* Scalaではコンパイル時にscala.runtimeパッケージにあるリッチラッパーに暗黙の型変換が行われる
